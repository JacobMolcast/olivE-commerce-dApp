// SPDX-License-Identifier: MIT

pragma solidity ^0.8.15;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract SupplyChainToken is ERC721, Ownable {

    uint256 public totalSupply;
    uint256 public maxSupply;
    uint walletBalance;

    constructor() payable ERC721("Olive Oil Harvest 2022", "OOH22"){
        maxSupply = 20000;
    }

    //The production is unknown until the harvesting is finished, in the constructor a aproximate amount of bottles is stated but the contact owner can decide to modify it after.
    function setMaxSupply(uint256 maxSupply_) external onlyOwner{
        maxSupply = maxSupply_;
    }

    function mint(address payable tokensWallet) virtual public payable{
        //Mint function is set by the ERC721 standard and needs to be public otherwise BottleBuy contract can't access it. This means that bad actors can mint without value a token if the below requirment is not stated. This way if the balance is of the account that receives ether doesn't increase, nobody can mint.
        require(tokensWallet.balance > walletBalance, 'no payment received');
        walletBalance = tokensWallet.balance;
        //This will prevent buying more bottles than produced
        require(maxSupply > totalSupply, 'sold out');  
        totalSupply++;
        uint256 tokenId = totalSupply;
        //_safeMint(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4, tokenId, tx.origin);
        _safeMint(tokensWallet, tokenId);
    }
}

contract SBT is SupplyChainToken{

    mapping(address => uint256) public balances;

    function mint(address payable tokenWallet) public payable override {
        //keep track of the buyers
        balances[tx.origin] ++; //increment by one and tx.origin will take the address of the buyer because if msg.sender is in here the contract address will be the one stated
        //mints the future soul and supply chain token
        super.mint(tokenWallet);
    }
}

contract BottleBuy is SBT{
    enum OliveHarvest{Pending, Started, Finished}
    OliveHarvest oliveHarvest;
    address contractOwner;
    address payable wallet;//account where the payments are received
    bool public isBuyEnabled;
    uint256 public bottlePrice = 0.065 ether; 

    constructor (address payable _wallet) {
        oliveHarvest = OliveHarvest.Pending;
        contractOwner = msg.sender;
        wallet = _wallet;
    }

    //Certain functions only should be managed by an admin
    modifier onlyContractOwner() {
        require(msg.sender == contractOwner);
        _;
    }

   //By default the variable isBuyEnabled is false. This way the contractOwner can change it.
    function toggleIsBuyEnabled() public onlyContractOwner {
        isBuyEnabled = !isBuyEnabled;
    }

    //Keep track of when the Harvest started and when it finished
    function harvestStatusChange() public onlyContractOwner {
        if (oliveHarvest == OliveHarvest.Pending){
            oliveHarvest = OliveHarvest.Started;
        } else {
            oliveHarvest = OliveHarvest.Finished;
        }
    }

    function harvestState() public view returns (string memory _oliveHarvest){
        if (oliveHarvest == OliveHarvest.Pending){
            _oliveHarvest = "The harvest is about to start";
        } else if (oliveHarvest == OliveHarvest.Started){
            _oliveHarvest = "We are working hard at the moment";
        } else {
            _oliveHarvest = "We are proud of have finish the harvesting one year more";
        }
        return _oliveHarvest;
    }

    function buyToken() public payable {
        //Prevent buyToken function to be enabled straight away and the admin can enable and stop it when required
        require(isBuyEnabled, 'Buy not enabled');
        //Security measure
        require(msg.value == bottlePrice, 'wrong value');
        //Send ether to the wallet. This step is the first one in order to avoid manipulation
        wallet.transfer(msg.value);
        //mint the SBT and SupplyChainToken
        super.mint(wallet);
    }

}
